// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: net.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "Net.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(SendMsgReply);
GPBObjCClassDeclaration(SendMsgRequest);
GPBObjCClassDeclaration(StreamConnectReply);
GPBObjCClassDeclaration(StreamConnectRequest);
GPBObjCClassDeclaration(StreamConnectRequest_ConnectInitReq);
GPBObjCClassDeclaration(StreamConnectRequest_encryptKeyInfo);

#pragma mark - NetRoot

@implementation NetRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription NetRoot_FileDescription = {
  .package = "dcapi.pb",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - SendMsgRequest

@implementation SendMsgRequest

@dynamic messageId;
@dynamic senderPubkey;
@dynamic receiverPubkey;
@dynamic appId;
@dynamic blockheight;
@dynamic encryptMsg;
@dynamic signature;

typedef struct SendMsgRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t blockheight;
  NSData *messageId;
  NSData *senderPubkey;
  NSData *receiverPubkey;
  NSData *appId;
  NSData *encryptMsg;
  NSData *signature;
} SendMsgRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "senderPubkey",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_SenderPubkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, senderPubkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "receiverPubkey",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_ReceiverPubkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, receiverPubkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_AppId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockheight",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_Blockheight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, blockheight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "encryptMsg",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_EncryptMsg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, encryptMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = SendMsgRequest_FieldNumber_Signature,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SendMsgRequest__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SendMsgRequest)
                                   messageName:@"SendMsgRequest"
                               fileDescription:&NetRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\t\000\002\014\000\003\016\000\004\005\000\006\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgReply

@implementation SendMsgReply


typedef struct SendMsgReply__storage_ {
  uint32_t _has_storage_[1];
} SendMsgReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SendMsgReply)
                                   messageName:@"SendMsgReply"
                               fileDescription:&NetRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SendMsgReply__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamConnectRequest

@implementation StreamConnectRequest

@dynamic payloadOneOfCase;
@dynamic initReq;
@dynamic challegeResp;
@dynamic frame;

typedef struct StreamConnectRequest__storage_ {
  uint32_t _has_storage_[2];
  StreamConnectRequest_ConnectInitReq *initReq;
  NSData *challegeResp;
  NSData *frame;
} StreamConnectRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "initReq",
        .dataTypeSpecific.clazz = GPBObjCClass(StreamConnectRequest_ConnectInitReq),
        .number = StreamConnectRequest_FieldNumber_InitReq,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectRequest__storage_, initReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "challegeResp",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_FieldNumber_ChallegeResp,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectRequest__storage_, challegeResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frame",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_FieldNumber_Frame,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectRequest__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StreamConnectRequest)
                                   messageName:@"StreamConnectRequest"
                               fileDescription:&NetRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamConnectRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void StreamConnectRequest_ClearPayloadOneOfCase(StreamConnectRequest *message) {
  GPBDescriptor *descriptor = [StreamConnectRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - StreamConnectRequest_ConnectInitReq

@implementation StreamConnectRequest_ConnectInitReq

@dynamic pubkey;
@dynamic hasEncryptKey, encryptKey;

typedef struct StreamConnectRequest_ConnectInitReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pubkey;
  StreamConnectRequest_encryptKeyInfo *encryptKey;
} StreamConnectRequest_ConnectInitReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubkey",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_ConnectInitReq_FieldNumber_Pubkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StreamConnectRequest_ConnectInitReq__storage_, pubkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "encryptKey",
        .dataTypeSpecific.clazz = GPBObjCClass(StreamConnectRequest_encryptKeyInfo),
        .number = StreamConnectRequest_ConnectInitReq_FieldNumber_EncryptKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StreamConnectRequest_ConnectInitReq__storage_, encryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StreamConnectRequest_ConnectInitReq)
                                   messageName:@"ConnectInitReq"
                               fileDescription:&NetRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamConnectRequest_ConnectInitReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(StreamConnectRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamConnectRequest_encryptKeyInfo

@implementation StreamConnectRequest_encryptKeyInfo

@dynamic type;
@dynamic symKey;
@dynamic reserve;

typedef struct StreamConnectRequest_encryptKeyInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSData *symKey;
  NSData *reserve;
} StreamConnectRequest_encryptKeyInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_encryptKeyInfo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StreamConnectRequest_encryptKeyInfo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "symKey",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_encryptKeyInfo_FieldNumber_SymKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StreamConnectRequest_encryptKeyInfo__storage_, symKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "reserve",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectRequest_encryptKeyInfo_FieldNumber_Reserve,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StreamConnectRequest_encryptKeyInfo__storage_, reserve),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StreamConnectRequest_encryptKeyInfo)
                                   messageName:@"encryptKeyInfo"
                               fileDescription:&NetRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamConnectRequest_encryptKeyInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(StreamConnectRequest)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StreamConnectReply

@implementation StreamConnectReply

@dynamic payloadOneOfCase;
@dynamic challenge;
@dynamic status;
@dynamic frame;

typedef struct StreamConnectReply__storage_ {
  uint32_t _has_storage_[2];
  int32_t status;
  NSData *challenge;
  NSData *frame;
} StreamConnectReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "challenge",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectReply_FieldNumber_Challenge,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectReply__storage_, challenge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectReply_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectReply__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "frame",
        .dataTypeSpecific.clazz = Nil,
        .number = StreamConnectReply_FieldNumber_Frame,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(StreamConnectReply__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StreamConnectReply)
                                   messageName:@"StreamConnectReply"
                               fileDescription:&NetRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StreamConnectReply__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void StreamConnectReply_ClearPayloadOneOfCase(StreamConnectReply *message) {
  GPBDescriptor *descriptor = [StreamConnectReply descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
